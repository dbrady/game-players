#!/usr/bin/env ruby
# draw-mine - render a Gem Miner 2 mine from its xml resource
#
# draw-mine <filename.xml>
#
# NOTES:
#
# This started as a logging/learning project with no known tiles and only gave
# me general ideas for the map. Now that it's had some time to bake, it's got a
# fairly robust (probably over half) set of known tiles. It's time to clean this
# up and make it be a real program
#
# TODO
# - [ ] Finish all the ore types and their values
# - [ ] Parse teleporters and put them on the map (see rainforest 7)
# - [ ] Render the legend down the right side of the map (provide cmd-line option
#   to disable it)
# - [ ] Render the map as raw/debug values for those times when I don't know why
#   the map is rendering something incorrectly
# - [ ] Parse insect objects and put them on the map (mosquitoes)
# - [ ] rainforest-007 renders OPEN to the right of the trap but it's actually a
#   ladder
# - [ ] cmd-line args, e.g. debugging, rendering style

require 'nokogiri'
require 'colorize'

def banner *objects, &block
  puts '-' * 80
  objects.each do |object|
    puts object.inspect
  end
  puts yield if block_given?
  puts '-' * 80
end

class Label
  attr_reader :name

  def initialize name
    @name = name
  end

  def ore?
    name =~ /\([d\?]+\)$/
  end

  def type
    ore? ? "ore" : "label"
  end

  def <=> other
    [type, name] <=> [other.type, other.name]
  end

  def to_s
    name
  end
end

class Mine
  attr_reader :doc, :legend, :tileset

  TILESET = [*'0'..'9', *'a'..'z', *'A'..'Z']

  EMPTY = ' '
  IMPASSABLE = '#'
  PORTAL = '@'
  BOULDER = 'O'
  OPEN_CAVERN = EMPTY.on_light_black
  LIFT = 'L'.white.on_light_black
  MARBLE = IMPASSABLE.white.on_light_yellow

  TRIGGER = '^'.red.on_light_black

  KNOWN_TILES = {
    0 => [' ', 'Nothing'], # object layer -- nothing here
    1 => [IMPASSABLE.light_black.on_black, 'Bedrock'],
    2 => [' '.on_cyan, 'Sky'],
    3 => ['.'.yellow.on_black, "Dirt"],
    8 => [BOULDER.light_white.on_light_black, "Boulder"],
    9 => [OPEN_CAVERN, "Open"],
    10 => [BOULDER.light_blue.on_light_white, "Ice Block"],
    12 => ['#'.black.on_yellow, "Sign"],
    15 => ["&".cyan.on_light_black, "Miner"],
    16 => ['v'.black.on_light_black, "Bat"],
    18 => [OPEN_CAVERN, "Mushrooms"],
    19 => [OPEN_CAVERN, "Hanging Vines"],
    20 => ['g'.white.on_black, "Guano, 9"],
    30 => ['o'.white.on_light_black, "White Opal (19)"],
    38 => ['b'.yellow.on_black, "Bauxite (10)"],
    41 => ['o'.green.on_black, "Green Opal (??)"],
    43 => ['g'.white.on_yellow, "Gold (37)"],
    45 => ['d'.cyan.on_black, "Diamond (45)"],
    49 => ['c'.white.on_black, "Coal (6)"],
    51 => ['I'.yellow.on_black, "Iron (14)"],
    53 => ['m'.light_red.on_black, "Manganese (??)"],
    54 => ['a'.light_red.on_black, "Amethyst (28)"],
    55 => ['F'.light_yellow.on_yellow, "Fossil"],
    56 => [LIFT, "Lift Shaft"],
    58 => [OPEN_CAVERN, "Open (Broken Stalagmite)"],
    59 => ['%'.magenta.on_light_black, "Coal Gas"],
    60 => [OPEN_CAVERN, "Open (Stalagmite)"],
    61 => [OPEN_CAVERN, "Open (Stalactite & Stalagmite)"],
    62 => [OPEN_CAVERN, "Open (Stalactite)"],
    63 => ['|'.light_yellow.on_black, "Support"],
    64 => ['|'.light_yellow.on_light_black, "Support (Charred)"],
    66 => ['.'.light_red.on_black, "Cave-in Dirt"],
    67 => ['#'.light_yellow.on_black, "Ladder"],
    68 => ['#'.light_yellow.on_light_black, "Ladder (Charred)"],
    69 => [PORTAL.black.on_cyan, "Teleport (Way Out)"],
    70 => [PORTAL.cyan.on_light_black, "Teleport (Intramine)"],
    71 => ["W".white.on_cyan, "Temple Pool"],
    72 => [OPEN_CAVERN, "Open"],
    73 => [OPEN_CAVERN, "Open (Torch)"],
    76 => ['^'.white.on_red, "Cave-In Trap Trigger"],
    77 => [MARBLE, "Temple Marble"],
    79 => ['/'.red.on_light_black, "Lever"],
    81 => [OPEN_CAVERN, "Open (Ice Stalagmite)"],
    82 => [OPEN_CAVERN, "Open (Ice Column)"],
    83 => [OPEN_CAVERN, "Open (Ice Stalactite)"],
    85 => ['#'.red.on_light_black, "Danger Sign"],
    90 => ["|".red.on_light_black, "Door"],
    94 => ['%'.light_yellow.on_yellow, "Scroll"],
    98 => ["j".green.on_black, "Jade (20)"],
    99 => [MARBLE, "Temple Marble"],
    100 => [MARBLE, "Temple Marble"],
    105 => [OPEN_CAVERN, "Open (Cobweb)"],
    106 => [LIFT.red, "Lift (Broken)"],
    107 => [OPEN_CAVERN, "Open"],
    110 => ['%'.light_yellow.on_yellow, "Map"],
    114 => ['='.light_yellow.on_light_black, "Walkway (Charred)"],
    115 => ['Q'.light_yellow.on_cyan, "Quest Giver"],
    120 => ['a'.blue.on_black, "Azurite (8)"],
    124 => [OPEN_CAVERN, "Open (Foliage)"],
    125 => [OPEN_CAVERN, "Open (Foliage)"],
    126 => [OPEN_CAVERN, "Open (Foliage)"],
    127 => [OPEN_CAVERN, "Open (Foliage)"],
    128 => [OPEN_CAVERN, "Open (Orchid)"],
    129 => [OPEN_CAVERN, "Open (Vine)"],
    130 => [OPEN_CAVERN, "Open"],
    131 => [OPEN_CAVERN, "Open"],
    132 => [OPEN_CAVERN, "Open (Foliage)"],
    133 => [OPEN_CAVERN, "Open (Foliage)"],
    134 => [MARBLE, "Temple Marble"],
    135 => [MARBLE, "Temple Marble"],
    136 => [OPEN_CAVERN, "Open (Light Shaft)"],
    137 => [OPEN_CAVERN, "Open (Foliage)"],
    140 => [OPEN_CAVERN, "Open (Palm Frond)"],
    141 => ['_'.white.on_red, "Trap Plate"],
    142 => [OPEN_CAVERN, "Open (Skulls on Spikes)"],
    151 => [OPEN_CAVERN, "Open (Foliage)"],
    153 => [OPEN_CAVERN, "Open (Foliage)"],
    155 => ['/'.light_yellow.on_black, "TikTok's Spear"],
    158 => [MARBLE.black, "Temple Marble (Peephole)"],
    160 => ['z'.white.on_black, "Zinc (20)"],
    161 => [OPEN_CAVERN, "Open (Foliage)"],
    162 => [OPEN_CAVERN, "Open (Foliage)"],
    165 => [OPEN_CAVERN, "Open (Foliage)"],
    166 => [OPEN_CAVERN, "Open (Foliage)"],
  }

  def initialize xml
    @doc = Nokogiri::XML xml
    @legend = {}
    @tileset = TILESET.dup
  end

  def known_tiles
    @known_tiles ||= Hash[
      KNOWN_TILES.map {|num, data|
        [num, [data.first, Label.new(data.last)]]
      }]
  end

  def self.load file
    Mine.new(File.open(file))
  end

  def height
    map_layers
      .map {|layer| layer["height"] || ""}
      .map {|height| height.to_i }
      .max
  end

  def width
    map_layers
      .map {|layer| layer["width"] || ""}
      .map {|width| width.to_i }
      .max
  end

  def map_layers
    doc.xpath "//map/layer"
  end

  def geologic_layer
    map_layers.find {|layer| layer["name"] == "main" }
  end

  def object_layer
    map_layers.find {|layer| layer["name"] == "objects" }
  end

  def render
    render_node doc.children.first
  end

  def describe_node node
    desc = node.name
    if node["name"]
      desc += ": #{node['name']}"
      if node["value"]
        value = node["value"]
        value = value[0..29] + '...' if value.size > 32
        desc += "='#{value}'"
      end
    end
    desc
  end

  def render_node node, indent=1
    text = []
    margin = ' ' * indent * 2
    text << "#{margin}#{describe_node(node)}"
    if !node.children.empty?
      node.children.each do |child|
        text.concat render_node(child, indent+1)
      end
    end
    text
  end

  def known_tile? tile
    known_tiles.key? tile
  end

  def encoding_for tile
    legend[tile] ||= if known_tile? tile
                       known_tiles[tile]
                     else
                       tileset.shift
                     end
  end

  def map_data
    @map_data ||= plot!
  end

  def plot!
    map_data = {}
    map_layers.each do |map|
      layer = map["name"]
      map_data[layer] = []
      data = map.xpath("data").children.first
      data.inner_text.each_line.with_index do |row, index|
        row.sub(/,$/, '')
        nums = row.split(/,/).map(&:to_i)
        nums.pop if nums.size == width+1
        next if nums.size != width
        # row = nums.map {|num| encoding_for(data, num)}
        map_data[layer] << nums
      end
    end
    map_data
  end

  def tile_at(x, y)
    object = map_data["objects"][y][x]
    return object unless object == 0
    map_data["main"][y][x]
  end

  def draw_map
    height.times do |y|
      print "%2d|" % (y-4)
      width.times do |x|
        tile = tile_at x, y
        display = encoding_for tile
        display = display.on_red unless known_tile?(tile)
        print "%s" % display
      end
      puts "|%2d" % (y-4)
    end

    puts '-' * 80
    puts "Legend:"
    knowns = legend.dup.keep_if {|key, val| known_tiles.values.include? val }
    unknowns = legend.dup.delete_if {|key, val| known_tiles.values.include? val }
    puts "Known Tiles: "
    puts knowns.invert.map {|key,val| "#{'%s' % key}:#{val}" }.join(', ')
    puts "Unknown Tiles: "
    puts unknowns.invert.map {|key,val| "#{key.on_red}:#{val}" }.join(', ')
    puts '-' * 80

    # debug
    # puts '-' * 80
    # height.times do |y|
    #   print "%2d|" % (y-4)
    #   width.times do |x|
    #     tile = tile_at x, y
    #     print "%3d," % tile
    #   end
    #   puts "|%2d" % (y-4)
    # end
  end

  def draw_map_old
    map_layers.each do |map|
      puts "#{map.name} #{map['name']}:"
      data = map.xpath("data").children.first
      data.inner_text.each_line.with_index do |row, index|
        row.sub(/,$/, '')
        nums = row.split(/,/).map(&:to_i)
        nums.pop if nums.size == width+1
        next if nums.size != width
        row = nums.map {|num| encoding_for(num)}.join('')
        puts "%2d|%s" % [index-5, row]
      end
    end

    puts '-' * 80
    puts legend.invert.map {|key,val| "#{key}:#{val}" }.join(', ')
    puts '-' * 80
  end
end

if __FILE__==$0
  mine = Mine.load ARGV[0]
  mine.map_layers.each do |map_layer|
    puts "%s: %sx%s" % [ map_layer["name"], map_layer["width"], map_layer["height"]]
  end

  puts "Mine: (#{mine.width}x#{mine.height})"

  mine.draw_map
end
