#!/usr/bin/env ruby
# draw-mine - render a Gem Miner 2 mine from its xml resource
#
# draw-mine <filename.xml>
#
# NOTES:
#
# This started as a logging/learning project with no known tiles and only gave
# me general ideas for the map. Now that it's had some time to bake, it's got a
# fairly robust (probably over half) set of known tiles. It's time to clean this
# up and make it be a real program
#
# TODO
# - [ ] Finish all the ore types and their values
# - [ ] Parse teleporters and put them on the map (see rainforest 7)
# - [ ] Render the legend down the right side of the map (provide cmd-line option
#   to disable it)
# - [ ] Render the map as raw/debug values for those times when I don't know why
#   the map is rendering something incorrectly
# - [ ] Parse insect objects and put them on the map (mosquitoes)
# - [ ] rainforest-007 renders OPEN to the right of the trap but it's actually a
#   ladder
# - [ ] cmd-line args, e.g. debugging, rendering style

require 'nokogiri'
require 'colorize'

def banner *objects, &block
  puts '-' * 80
  objects.each do |object|
    puts object.inspect
  end
  puts yield if block_given?
  puts '-' * 80
end

class Label
  include Comparable
  attr_reader :symbol, :name

  # These constants affect sort order of Labels
  LABEL = 0
  ORE = 1
  UNKNOWN = 2

  def initialize symbol, name
    @symbol, @name = symbol, name
  end

  def ore?
    name =~ /\([\d]+\)$/
  end

  def type
    return UNKNOWN unless name
    ore? ? ORE : LABEL
  end

  def type_name
    case type
    when LABEL then "LABEL"
    when ORE then "ORE"
    when UNKNOWN then "UNKNOWN"
    end
  end

  def <=> other
    if ore? && other.ore?
      value <=> other.value
    else
      [type, name] <=> [other.type, other.name]
    end
  end

  def value
    return 0 unless ore?
    name[/\d+/].to_i
  end

  def to_s
    "%s" % symbol
  end
end

class Legend
  attr_reader :mine, :lines
  def initialize mine
    @mine = mine
    @lines = [
      "Known Geology:",
      *mine.known_geology_legend.values.sort,
      "",
      "Known Ores:",
      *mine.known_ore_legend.values.sort,
      "",
      "Unknown Tiles:",
      *mine.unknown_legend.values.sort
    ]
  end

  # Returns the next line to render for a vertical legend.
  # Given n known tiles and m unknown tiles,
  #
  # Line 0 is always "Known Tiles:"
  # Lines 1..n are the known tiles, sorted by type and name
  # Line n+1 is blank
  # Lines n+2 is always "Unknown Tiles:"
  # Lines n+3..n+3+m are the unknown tiles, sorted by symbol
  def next_line
    @line_enum ||= @lines.each
    begin
      label = @line_enum.next
      if label.respond_to? :name
        "%s: %s" % [label.symbol, label.name]
      else
        label
      end
    rescue StopIteration
      ""
    end
  end
end

class Mine
  attr_reader :doc, :legend, :tileset

  TILESET = [*'0'..'9', *'a'..'z', *'A'..'Z']

  EMPTY = ' '
  IMPASSABLE = '@'
  PORTAL = '@'
  BOULDER = 'O'
  OPEN_CAVERN = EMPTY.on_light_black
  LIFT = 'L'.white.on_light_black
  MARBLE = IMPASSABLE.white.on_light_yellow

  TRIGGER = '^'.red.on_light_black

  KNOWN_TILES = {
    0 => [' ', 'Nothing'], # object layer -- nothing here
    1 => [IMPASSABLE.light_black.on_black, 'Bedrock'],
    2 => [' '.on_cyan, 'Sky'],
    3 => ['.'.yellow.on_black, "Dirt"],
    8 => [BOULDER.light_white.on_light_black, "Boulder"],
    9 => [OPEN_CAVERN, "Open"],
    10 => [BOULDER.light_blue.on_light_white, "Ice Block"],
    12 => ['#'.black.on_yellow, "Sign"],
    15 => ["&".cyan.on_light_black, "Miner"],
    16 => ['v'.black.on_light_black, "Bat"],
    18 => [OPEN_CAVERN, "Mushrooms"],
    19 => [OPEN_CAVERN, "Hanging Vines"],
    20 => ['g'.white.on_black, "Guano (9)"],
    25 => ['F'.light_yellow.on_yellow, "Fossilized Claw"],
    27 => ['F'.light_yellow.on_yellow, "Fossilized Vertebra"],
    28 => ['u'.light_green.on_black, "Uranium (32)"],
    29 => ['t'.light_blue.on_black, "Topaz (22)"],
    30 => ['o'.white.on_light_black, "White Opal (19)"],
    33 => ['F'.light_yellow.on_yellow, "Fossilized Triceratops Skull"],
    34 => ['F'.light_yellow.on_yellow, "Fossilized Femur"],
    35 => ['t'.white.on_black, "Tin (7)"],
    38 => ['b'.yellow.on_black, "Bauxite (10)"],
    40 => ['o'.black.on_white, "Black Opal (25)"],
    41 => ['o'.green.on_black, "Green Opal (21)"],
    42 => ['g'.light_black.on_black, "Graphite (12)"],
    43 => ['g'.white.on_yellow, "Gold (37)"],
    45 => ['d'.cyan.on_black, "Diamond (45)"],
    47 => ['c'.yellow.on_black, "Copper (15)"],
    49 => ['c'.white.on_black, "Coal (6)"],
    51 => ['I'.yellow.on_black, "Iron (14)"],
    53 => ['m'.light_red.on_black, "Manganese (999)"],
    54 => ['a'.light_red.on_black, "Amethyst (28)"],
    55 => ['F'.light_yellow.on_yellow, "Fossil"],
    56 => [LIFT, "Lift Shaft"],
    57 => [LIFT.bold, "Lift Car"],
    58 => [OPEN_CAVERN, "Open (Broken Stalagmite)"],
    59 => ['%'.magenta.on_light_black, "Coal Gas"],
    60 => [OPEN_CAVERN, "Open (Stalagmite)"],
    61 => [OPEN_CAVERN, "Open (Stalactite & Stalagmite)"],
    62 => [OPEN_CAVERN, "Open (Stalactite)"],
    63 => ['|'.light_yellow.on_black, "Support"],
    64 => ['|'.light_yellow.on_light_black, "Support (Charred)"],
    66 => ['.'.light_red.on_black, "Cave-in Dirt"],
    67 => ['#'.light_yellow.on_black, "Ladder"],
    68 => ['#'.light_yellow.on_light_black, "Ladder (Charred)"],
    69 => [PORTAL.black.on_cyan, "Teleport (Way Out)"],
    70 => [PORTAL.cyan.on_light_black, "Teleport (Intramine)"],
    71 => ["W".white.on_cyan, "Temple Pool"],
    72 => [OPEN_CAVERN, "Open"],
    73 => [OPEN_CAVERN, "Open (Torch)"],
    76 => ['^'.white.on_red, "Cave-In Trap Trigger"],
    77 => [MARBLE, "Temple Marble"],
    79 => ['/'.red.on_light_black, "Lever"],
    81 => [OPEN_CAVERN, "Open (Ice Stalagmite)"],
    82 => [OPEN_CAVERN, "Open (Ice Column)"],
    83 => [OPEN_CAVERN, "Open (Ice Stalactite)"],
    85 => ['#'.red.on_light_black, "Danger Sign"],
    90 => ["|".red.on_light_black, "Door"],
    94 => ['%'.light_yellow.on_yellow, "Scroll"],
    97 => ['d'.magenta.on_light_magenta, "Pink Diamond (50)"],
    98 => ["j".green.on_black, "Jade (24)"],
    99 => [MARBLE, "Temple Marble"],
    100 => [MARBLE, "Temple Marble"],
    105 => [OPEN_CAVERN, "Open (Cobweb)"],
    106 => [LIFT.red, "Lift Car (Broken)"],
    107 => [OPEN_CAVERN, "Open"],
    110 => ['%'.light_yellow.on_yellow, "Map"],
    111 => ['L'.light_yellow.on_red, "Lava"],
    114 => ['='.light_yellow.on_light_black, "Walkway (Charred)"],
    115 => ['Q'.light_yellow.on_cyan, "Quest Giver"],
    120 => ['a'.blue.on_black, "Azurite (8)"],
    122 => ['n'.white.on_black, "Nickel (5)"],
    123 => ['b'.white.on_black, "Borax (11)"],
    124 => [OPEN_CAVERN, "Open (Foliage)"],
    125 => [OPEN_CAVERN, "Open (Foliage)"],
    126 => [OPEN_CAVERN, "Open (Foliage)"],
    127 => [OPEN_CAVERN, "Open (Foliage)"],
    128 => [OPEN_CAVERN, "Open (Orchid)"],
    129 => [OPEN_CAVERN, "Open (Vine)"],
    130 => [OPEN_CAVERN, "Open"],
    131 => [OPEN_CAVERN, "Open"],
    132 => [OPEN_CAVERN, "Open (Foliage)"],
    133 => [OPEN_CAVERN, "Open (Foliage)"],
    134 => [MARBLE, "Temple Marble"],
    135 => [MARBLE, "Temple Marble"],
    136 => [OPEN_CAVERN, "Open (Light Shaft)"],
    137 => [OPEN_CAVERN, "Open (Foliage)"],
    138 => ['s'.light_yellow.on_black, "Sulfur (17)"],
    139 => ['#'.light_red.on_black, "Breakable Wall"],
    140 => [OPEN_CAVERN, "Open (Palm Frond)"],
    141 => ['_'.white.on_red, "Trap Plate"],
    142 => [OPEN_CAVERN, "Open (Skulls on Spikes)"],
    149 => ['m'.light_magenta.on_black, "Mica (5)"],
    151 => [OPEN_CAVERN, "Open (Foliage)"],
    153 => [OPEN_CAVERN, "Open (Foliage)"],
    154 => ['J'.light_green.on_green, "Jade Skull"],
    155 => ['/'.light_yellow.on_black, "TikTok's Spear"],
    158 => [MARBLE.black, "Temple Marble (Peephole)"],
    160 => ['z'.white.on_black, "Zinc (20)"],
    161 => [OPEN_CAVERN, "Open (Foliage)"],
    162 => [OPEN_CAVERN, "Open (Foliage)"],
    165 => [OPEN_CAVERN, "Open (Foliage)"],
    166 => [OPEN_CAVERN, "Open (Foliage)"],
    167 => [OPEN_CAVERN, "Open (Coral)"],
    168 => ['j'.light_green.on_green, "Jade Skull Fragment"],
  }

  def initialize xml
    @doc = Nokogiri::XML xml
    @legend = {}
    @tileset = TILESET.dup
  end

  def known_tiles
    @known_tiles ||= Hash[
      KNOWN_TILES.map {|num, data|
        [num, Label.new(*data)]
      }]
  end

  def known_legend
    legend.dup.keep_if {|key, val| known_tiles.values.include? val }
  end

  def known_geology_legend
    leg = legend.dup.keep_if {|key, val| known_tiles.values.include?(val) && !val.ore? }
    dedup = Hash[leg.map {|tile, label| [label.symbol, [tile, label]]}]
    Hash[
      dedup.map {|symbol, data| data }
    ]
  end

  def known_ore_legend
    legend.dup.keep_if {|key, val| known_tiles.values.include?(val) && val.ore? }
  end

  def unknown_legend
    legend.dup.delete_if {|key, val| known_tiles.values.include? val }
  end


  def self.load file
    Mine.new(File.open(file))
  end

  def height
    map_layers
      .map {|layer| layer["height"] || ""}
      .map {|height| height.to_i }
      .max
  end

  def width
    map_layers
      .map {|layer| layer["width"] || ""}
      .map {|width| width.to_i }
      .max
  end

  def map_layers
    doc.xpath "//map/layer"
  end

  def geologic_layer
    map_layers.find {|layer| layer["name"] == "main" }
  end

  def object_layer
    map_layers.find {|layer| layer["name"] == "objects" }
  end

  def describe_node node
    desc = node.name
    desc += " type: #{node['type']}" if node.name == 'object'
    desc += " (#{node['x']}x#{node['y']})" if node['type'] == 'insect'
    if node["name"]
      desc += ": #{node['name']}"
      if node["value"]
        value = node["value"]
        value = value[0..29] + '...' if value.size > 32
        desc += "='#{value}'"
      end
    end
    desc
  end

  def render
    banner doc.children.size
    banner doc.children.first.name
    render_node doc.children.first
  end

  def render_node node, indent=1
    text = []
    margin = ' ' * indent * 2
    text << "#{margin}#{describe_node(node)}"
    if !node.children.empty?
      node.children.each do |child|
        text.concat render_node(child, indent+1)
      end
    end
    text
  end

  def known_tile? tile
    known_tiles.key? tile
  end

  def encoding_for tile
    legend[tile] ||= if known_tile? tile
                       known_tiles[tile]
                     else
                       Label.new(tileset.shift.to_s.white.on_red, "Uknown")
                     end
  end

  def map_data
    @map_data ||= plot!
  end

  def plot!
    map_data = {}
    map_layers.each do |map|
      layer = map["name"]
      map_data[layer] = []
      data = map.xpath("data").children.first
      data.inner_text.each_line.with_index do |row, index|
        row.sub(/,$/, '')
        nums = row.split(/,/).map(&:to_i)
        nums.pop if nums.size == width+1
        next if nums.size != width
        map_data[layer] << nums
      end
    end
    map_data
  end

  def tile_at(x, y)
    object = map_data["objects"][y][x]
    return object unless object == 0
    map_data["main"][y][x]
  end

  def encode_tiles!
    height.times do |y|
      width.times do |x|
        tile = tile_at x, y
        display = encoding_for tile
      end
    end
  end

  def index_format
    digits = 1 + (Math.log([height, width].max) / Math.log(10)).to_i
    "%#{digits}d"
  end

  def draw_map
    encode_tiles!
    side_legend = Legend.new self
    height.times do |y|
      print "#{index_format}|" % (y-4)
      width.times do |x|
        tile = tile_at x, y
        display = encoding_for tile
        print "%s" % display
      end
      puts "|#{index_format}  %s" % [(y-4), side_legend.next_line]
    end

    puts '-' * 80
    puts "Legend:"
    puts "Known Tiles: "
    puts known_legend.invert.map {|key,val| "#{'%s' % key}:#{val}" }.join(', ')
    puts "Unknown Tiles: "
    puts unknown_legend.invert.map {|key,val| "#{'%s' % key}:#{val}" }.join(', ')
    puts '-' * 80

    # debug
    # puts '-' * 80
    # height.times do |y|
    #   print "%2d|" % (y-4)
    #   width.times do |x|
    #     tile = tile_at x, y
    #     print "%3d," % tile
    #   end
    #   puts "|%2d" % (y-4)
    # end
  end

  def draw_map_old
    map_layers.each do |map|
      puts "#{map.name} #{map['name']}:"
      data = map.xpath("data").children.first
      data.inner_text.each_line.with_index do |row, index|
        row.sub(/,$/, '')
        nums = row.split(/,/).map(&:to_i)
        nums.pop if nums.size == width+1
        next if nums.size != width
        row = nums.map {|num| encoding_for(num)}.join('')
        puts "%2d|%s" % [index-5, row]
      end
    end

    puts '-' * 80
    puts legend.invert.map {|key,val| "#{key}:#{val}" }.join(', ')
    puts '-' * 80
  end
end

if __FILE__==$0
  mine = Mine.load ARGV[0]
  puts "Mine: (#{mine.width}x#{mine.height})"

  mine.draw_map
  #puts mine.render
end
