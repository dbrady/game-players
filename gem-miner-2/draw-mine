#!/usr/bin/env ruby
require 'nokogiri'
require 'colorize'

def banner *objects, &block
  puts '-' * 80
  objects.each do |object|
    puts object.inspect
  end
  puts yield if block_given?
  puts '-' * 80
end

class Mine
  attr_reader :doc, :legend, :tileset

  TILESET = [*'0'..'9', *'a'..'z', *'A'..'Z']
  OPEN_CAVERN = ' '.on_light_black

  KNOWN_TILES = {
    0 => ' ', # object layer -- nothing here
    1 => '#'.light_black.on_black, # bedrock
    2 => ' '.on_cyan, # sky
    3 => '.'.yellow.on_black, # dirt
    8 => "O".light_white.on_light_black, # boulder
    9 => OPEN_CAVERN,
    10 => "O".light_blue.on_light_white, # ice block
    43 => 'g'.white.on_yellow, # gold
    49 => 'c'.white.on_black, # coal
    51 => 'I'.yellow.on_black, # iron
    56 => 'L'.white.on_light_black, # lift shaft
    58 => OPEN_CAVERN, # actually a broken stalagmite
    63 => '|'.light_yellow.on_black, # support beam
    67 => '#'.light_yellow.on_black, # ladder
    68 => '#'.light_yellow.on_light_black, # burnt ladder
    70 => '@'.cyan.on_black, # teleport/fast travel
    81 => '^'.cyan.on_light_black, # ice stalagmite
    82 => '|'.cyan.on_light_black, # ice column
    83 => 'v'.cyan.on_light_black, # ice stalactite
  }

  def initialize xml
    @doc = Nokogiri::XML xml
    @legend = {}
    @tileset = TILESET.dup
  end

  def self.load file
    Mine.new(File.open(file))
  end

  def height
    map_layers
      .map {|layer| layer["height"] || ""}
      .map {|height| height.to_i }
      .max
  end

  def width
    map_layers
      .map {|layer| layer["width"] || ""}
      .map {|width| width.to_i }
      .max
  end

  def map_layers
    doc.xpath "//map/layer"
  end

  def geologic_layer
    map_layers.find {|layer| layer["name"] == "main" }
  end

  def object_layer
    map_layers.find {|layer| layer["name"] == "objects" }
  end

  def render
    render_node doc.children.first
  end

  def describe_node node
    desc = node.name
    if node["name"]
      desc += ": #{node['name']}"
      if node["value"]
        value = node["value"]
        value = value[0..29] + '...' if value.size > 32
        desc += "='#{value}'"
      end
    end
    desc
  end

  def render_node node, indent=1
    text = []
    margin = ' ' * indent * 2
    text << "#{margin}#{describe_node(node)}"
    if !node.children.empty?
      node.children.each do |child|
        text.concat render_node(child, indent+1)
      end
    end
    text
  end

  def known_tile? tile
    KNOWN_TILES.key? tile
  end

  def encoding_for tile
    legend[tile] ||= if known_tile? tile
                       KNOWN_TILES[tile]
                     else
                       tileset.shift
                     end
  end

  def map_data
    @map_data ||= plot!
  end

  def plot!
    map_data = {}
    map_layers.each do |map|
      layer = map["name"]
      map_data[layer] = []
      data = map.xpath("data").children.first
      data.inner_text.each_line.with_index do |row, index|
        row.sub(/,$/, '')
        nums = row.split(/,/).map(&:to_i)
        nums.pop if nums.size == width+1
        next if nums.size != width
        # row = nums.map {|num| encoding_for(data, num)}
        map_data[layer] << nums
      end
    end
    map_data
  end

  def tile_at(x, y)
    object = map_data["objects"][y][x]
    return object unless object == 0
    map_data["main"][y][x]
  end

  def draw_map
    height.times do |y|
      print "%2d|" % y
      width.times do |x|
        tile = tile_at x, y
        display = encoding_for tile
        display = display.on_red unless known_tile?(tile)
        print display
      end
      puts
    end
    # map_data.each do |name, rows|
    #   puts "#{name}:"
    #   rows.each.with_index do |row, index|
    #     text = row.map {|tile| encoding_for(tile) }.join('')
    #     puts "%2d|%s" % [index-5, text]
    #   end
    # end

    puts '-' * 80
    puts "Legend:"
    knowns = legend.dup.keep_if {|key, val| KNOWN_TILES.values.include? val }
    unknowns = legend.dup.delete_if {|key, val| KNOWN_TILES.values.include? val }
    puts "Known Tiles: "
    puts knowns.invert.map {|key,val| "#{key}:#{val}" }.join(', ')
    puts "Unknown Tiles: "
    puts unknowns.invert.map {|key,val| "#{key}:#{val}" }.join(', ')
    puts '-' * 80
  end

  def draw_map_old
    map_layers.each do |map|
      puts "#{map.name} #{map['name']}:"
      data = map.xpath("data").children.first
      data.inner_text.each_line.with_index do |row, index|
        row.sub(/,$/, '')
        nums = row.split(/,/).map(&:to_i)
        nums.pop if nums.size == width+1
        next if nums.size != width
        row = nums.map {|num| encoding_for(num)}.join('')
        puts "%2d|%s" % [index-5, row]
      end
    end

    puts '-' * 80
    puts legend.invert.map {|key,val| "#{key}:#{val}" }.join(', ')
    puts '-' * 80
  end
end

if __FILE__==$0
  mine = Mine.load ARGV[0]
  mine.map_layers.each do |map_layer|
    puts "%s: %sx%s" % [ map_layer["name"], map_layer["width"], map_layer["height"]]
  end

  puts "Mine: (#{mine.width}x#{mine.height})"

  mine.draw_map
  # puts mine.map_layer.inspect
#  puts mine.render
end
