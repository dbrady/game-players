#!/usr/bin/env ruby
require 'nokogiri'
require 'colorize'

def banner *objects, &block
  puts '-' * 80
  objects.each do |object|
    puts object.inspect
  end
  puts yield if block_given?
  puts '-' * 80
end

class Mine
  attr_reader :doc, :legend, :tileset

  TILESET = [*'0'..'9', *'a'..'z', *'A'..'Z']

  EMPTY = ' '
  IMPASSABLE = '#'
  PORTAL = '@'
  BOULDER = 'O'
  OPEN_CAVERN = EMPTY.on_light_black
  LIFT = 'L'.white.on_light_black
  MARBLE = IMPASSABLE.white.on_light_yellow

  TRIGGER = '^'.red.on_light_black

  KNOWN_TILES = {
    0 => ' ', # object layer -- nothing here
    1 => IMPASSABLE.light_black.on_black, # bedrock
    2 => ' '.on_cyan, # sky
    3 => '.'.yellow.on_black, # dirt
    8 => BOULDER.light_white.on_light_black, # boulder
    9 => OPEN_CAVERN,
    10 => BOULDER.light_blue.on_light_white, # ice block
    15 => "&".cyan.on_light_black, # miner dude
    16 => 'v'.black.on_light_black, # bat
    18 => OPEN_CAVERN, # mushrooms
    19 => OPEN_CAVERN, # hanging vines
    20 => 'g'.white.on_black, # guano
    30 => 'o'.white.on_light_black, # white opal, 19
    41 => 'o'.green.on_black, # green opal
    43 => 'g'.white.on_yellow, # gold, 37
    45 => 'd'.cyan.on_black, # diamond, 45
    49 => 'c'.white.on_black, # coal, 6
    51 => 'I'.yellow.on_black, # iron, 14
    53 => 'm'.light_red.on_black, # manganese
    54 => 'a'.light_red.on_black, # amethyst, 28
    56 => LIFT, # lift shaft
    58 => OPEN_CAVERN, # actually a broken stalagmite
    59 => '%'.magenta.on_light_black, # coal gas
    60 => OPEN_CAVERN, # stalagmite
    61 => OPEN_CAVERN, # unconnected stalactite & stalagmite
    62 => OPEN_CAVERN, # stalactite
    63 => '|'.light_yellow.on_black, # support beam
    64 => '|'.light_yellow.on_light_black, # charred support beam
    66 => '.'.light_red.on_black, # dirt that will cave in
    67 => '#'.light_yellow.on_black, # ladder
    68 => '#'.light_yellow.on_light_black, # charred ladder
    69 => PORTAL.black.on_cyan, # teleport WAY OUT
    70 => PORTAL.cyan.on_light_black, # teleport/fast travel
    71 => "W".white.on_cyan, # pool in temple
    72 => OPEN_CAVERN, # open cavern with quest trigger
    76 => '^'.white.on_red, # cave-in trap trigger
    77 => MARBLE, # single temple brick
    79 => '/'.red.on_light_black, # lever
    81 => OPEN_CAVERN, # ice stalagmite
    82 => OPEN_CAVERN, # ice column
    83 => OPEN_CAVERN, # ice stalactite
    85 => '#'.red.on_light_black, # DANGER! sign
    90 => "|".red.on_light_black, # temple door
    99 => MARBLE, # double temple brick, left
    100 => MARBLE, # double temple brick, right
    105 => OPEN_CAVERN, # cobweb top right
    106 => LIFT.red, # broken lift
    107 => OPEN_CAVERN, # open cavern with quest trigger
    128 => OPEN_CAVERN, # orchid
    129 => OPEN_CAVERN, # hanging vine
    130 => OPEN_CAVERN, # open cavern with quest trigger
    136 => OPEN_CAVERN, # hole with light shaft
    140 => OPEN_CAVERN, # giant palm frond
    114 => '='.light_yellow.on_light_black, # charred walkway
    115 => 'P'.light_yellow.on_cyan, # the biplane
    131 => OPEN_CAVERN, # open cavern with quest trigger
    133 => OPEN_CAVERN, # tuft of green grass
    142 => OPEN_CAVERN, # skulls on spikes
    158 => MARBLE.black, # marble with peephole crack
    165 => OPEN_CAVERN, # fronds with berries
  }

  def initialize xml
    @doc = Nokogiri::XML xml
    @legend = {}
    @tileset = TILESET.dup
  end

  def self.load file
    Mine.new(File.open(file))
  end

  def height
    map_layers
      .map {|layer| layer["height"] || ""}
      .map {|height| height.to_i }
      .max
  end

  def width
    map_layers
      .map {|layer| layer["width"] || ""}
      .map {|width| width.to_i }
      .max
  end

  def map_layers
    doc.xpath "//map/layer"
  end

  def geologic_layer
    map_layers.find {|layer| layer["name"] == "main" }
  end

  def object_layer
    map_layers.find {|layer| layer["name"] == "objects" }
  end

  def render
    render_node doc.children.first
  end

  def describe_node node
    desc = node.name
    if node["name"]
      desc += ": #{node['name']}"
      if node["value"]
        value = node["value"]
        value = value[0..29] + '...' if value.size > 32
        desc += "='#{value}'"
      end
    end
    desc
  end

  def render_node node, indent=1
    text = []
    margin = ' ' * indent * 2
    text << "#{margin}#{describe_node(node)}"
    if !node.children.empty?
      node.children.each do |child|
        text.concat render_node(child, indent+1)
      end
    end
    text
  end

  def known_tile? tile
    KNOWN_TILES.key? tile
  end

  def encoding_for tile
    legend[tile] ||= if known_tile? tile
                       KNOWN_TILES[tile]
                     else
                       tileset.shift
                     end
  end

  def map_data
    @map_data ||= plot!
  end

  def plot!
    map_data = {}
    map_layers.each do |map|
      layer = map["name"]
      map_data[layer] = []
      data = map.xpath("data").children.first
      data.inner_text.each_line.with_index do |row, index|
        row.sub(/,$/, '')
        nums = row.split(/,/).map(&:to_i)
        nums.pop if nums.size == width+1
        next if nums.size != width
        # row = nums.map {|num| encoding_for(data, num)}
        map_data[layer] << nums
      end
    end
    map_data
  end

  def tile_at(x, y)
    object = map_data["objects"][y][x]
    return object unless object == 0
    map_data["main"][y][x]
  end

  def draw_map
    height.times do |y|
      print "%2d|" % (y-4)
      width.times do |x|
        tile = tile_at x, y
        display = encoding_for tile
        display = display.on_red unless known_tile?(tile)
        print display
      end
      puts "|%2d" % (y-4)
    end
    # map_data.each do |name, rows|
    #   puts "#{name}:"
    #   rows.each.with_index do |row, index|
    #     text = row.map {|tile| encoding_for(tile) }.join('')
    #     puts "%2d|%s" % [index-5, text]
    #   end
    # end

    puts '-' * 80
    puts "Legend:"
    knowns = legend.dup.keep_if {|key, val| KNOWN_TILES.values.include? val }
    unknowns = legend.dup.delete_if {|key, val| KNOWN_TILES.values.include? val }
    puts "Known Tiles: "
    puts knowns.invert.map {|key,val| "#{key}:#{val}" }.join(', ')
    puts "Unknown Tiles: "
    puts unknowns.invert.map {|key,val| "#{key}:#{val}" }.join(', ')
    puts '-' * 80
  end

  def draw_map_old
    map_layers.each do |map|
      puts "#{map.name} #{map['name']}:"
      data = map.xpath("data").children.first
      data.inner_text.each_line.with_index do |row, index|
        row.sub(/,$/, '')
        nums = row.split(/,/).map(&:to_i)
        nums.pop if nums.size == width+1
        next if nums.size != width
        row = nums.map {|num| encoding_for(num)}.join('')
        puts "%2d|%s" % [index-5, row]
      end
    end

    puts '-' * 80
    puts legend.invert.map {|key,val| "#{key}:#{val}" }.join(', ')
    puts '-' * 80
  end
end

if __FILE__==$0
  mine = Mine.load ARGV[0]
  mine.map_layers.each do |map_layer|
    puts "%s: %sx%s" % [ map_layer["name"], map_layer["width"], map_layer["height"]]
  end

  puts "Mine: (#{mine.width}x#{mine.height})"

  mine.draw_map
  # puts mine.map_layer.inspect
#  puts mine.render
end
